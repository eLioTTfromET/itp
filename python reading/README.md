# Python Reading
+ [Think Python by Allen B. Downey](https://greenteapress.com/thinkpython2/html/index.html)

Eliott Mendoza

## Ch. 1: The way of the program
+ what I knew: "So you can think of programming as the process of breaking a large, complex task into smaller and smaller subtasks until the subtasks are simple enough to be performed with one of these basic instructions."

I like programming for this reason, and I generally think of programming this way. Although it is very eloquent the way they put it.
+ what I didn't know: "Preparing for these reactions might help you deal with them. One approach is to think of the computer as an employee with certain strengths, like speed and precision, and particular weaknesses, like lack of empathy and inability to grasp the big picture. Your job is to be a good manager: find ways to take advantage of the strengths and mitigate the weaknesses. And find ways to use your emotions to engage with the problem, without letting your reactions interfere with your ability to work effectively."

I had never thought of the computer in this way before! This is a neat way to think of the computer that is really helpful and resonates with me.

## Ch. 3: Functions
+ what I knew: "One of the most useful features of programming languages is their ability to take small building blocks and compose them. For example, the argument of a function can be any kind of expression, including arithmetic operators: x = math.sin(degrees / 360.0 * 2 * math.pi)"

This makes programming so much easier, when me and the computer can just mutually agree that any variable means something more complex. This makes it easier to get to the point of the program.
+ what I didn't know: "Inside the function, the arguments are assigned to variables called parameters. Here is a definition for a function that takes an argument: def print_twice(bruce): print(bruce) print(bruce) This function assigns the argument to a parameter named bruce. When the function is called, it prints the value of the parameter (whatever it is) twice. This function works with any value that can be printed."

I have worked with something similar in C, but this is a lot more intuitive in Python. It makes a lot more sense, the way variables are local to the function. I like this.

## Ch. 5: Conditionals and recursion
+ what I knew: "When a syntax or runtime error occurs, the error message contains a lot of information, but it can be overwhelming. The most useful parts are usually: What kind of error it was, and Where it occurred."

I've known what errors can show and how they can be helpful, especially for debugging. Although, I also knew that they can sometimes be wrong (or show what you need to fix).
+ what I didn't know: "Also, you can extract the right-most digit or digits from a number. For example, x % 10 yields the right-most digit of x (in base 10). Similarly x % 100 yields the last two digits."

I knew about the modulus operator, but I never thought of using the modulus operator in this way. I always thought of its use for getting the remainder, but getting the last needed digits is also a very practical application of modulus.

## Ch. 10: Lists
+ what I knew: "total += x is equivalent to total = total + x"

This is something that I used in C, and something I think you brought up in class. There are shorter ways to do things in programming that may not seem intuitive at first, but they help speed the process up especially once they become more intuitive.
+ what I didn't know: "The following list contains a string, a float, an integer, and (lo!) another list: ['spam', 2.0, 5, [10, 20]] A list within another list is nested."

I didn't know a list could exist as an element of a list, i.e. the nested list. This is useful information.
